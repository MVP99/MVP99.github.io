<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.1.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.1">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.1.1',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="javascript的typeof返回哪些数据类型Object number function boolean underfind string    typeof [] == ‘object’    typeof null == ‘object’ 例举3种强制类型转换和2种隐式类型转换？强制（parseInt,parseFloat,number）隐式（== - ===） split() join">
<meta name="keywords" content="前端">
<meta property="og:type" content="article">
<meta property="og:title" content="前端面试总结">
<meta property="og:url" content="http://yoursite.com/2019/05/07/前端面试总结/index.html">
<meta property="og:site_name" content="little bea">
<meta property="og:description" content="javascript的typeof返回哪些数据类型Object number function boolean underfind string    typeof [] == ‘object’    typeof null == ‘object’ 例举3种强制类型转换和2种隐式类型转换？强制（parseInt,parseFloat,number）隐式（== - ===） split() join">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-05-07T14:31:34.944Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="前端面试总结">
<meta name="twitter:description" content="javascript的typeof返回哪些数据类型Object number function boolean underfind string    typeof [] == ‘object’    typeof null == ‘object’ 例举3种强制类型转换和2种隐式类型转换？强制（parseInt,parseFloat,number）隐式（== - ===） split() join">


  


  <link rel="alternate" href="/atom.xml" title="little bea" type="application/atom+xml">



  
  
  <link rel="canonical" href="http://yoursite.com/2019/05/07/前端面试总结/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>前端面试总结 | little bea</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">little bea</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/07/前端面试总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="_doucc">
      <meta itemprop="description" content="没人能在我的BGM里打败我">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="little bea">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">前端面试总结

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-05-07 12:57:39 / 修改时间：22:31:34" itemprop="dateCreated datePublished" datetime="2019-05-07T12:57:39+08:00">2019-05-07</time>
            

            
              

              
            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="javascript的typeof返回哪些数据类型"><a href="#javascript的typeof返回哪些数据类型" class="headerlink" title="javascript的typeof返回哪些数据类型"></a>javascript的typeof返回哪些数据类型</h2><p>Object number function boolean underfind string<br>    typeof [] == ‘object’<br>    typeof null == ‘object’</p>
<h2 id="例举3种强制类型转换和2种隐式类型转换？"><a href="#例举3种强制类型转换和2种隐式类型转换？" class="headerlink" title="例举3种强制类型转换和2种隐式类型转换？"></a>例举3种强制类型转换和2种隐式类型转换？</h2><p>强制（parseInt,parseFloat,number）<br>隐式（== - ===）</p>
<h2 id="split-join-的区别"><a href="#split-join-的区别" class="headerlink" title="split() join() 的区别"></a>split() join() 的区别</h2><p>前者是切割成数组的形式，后者是将数组转换成字符串</p>
<h2 id="数组方法pop-push-unshift-shift"><a href="#数组方法pop-push-unshift-shift" class="headerlink" title="数组方法pop() push() unshift() shift()"></a>数组方法pop() push() unshift() shift()</h2><p>Unshift()头部添加 shift()头部删除<br>Push()尾部添加 pop()尾部删除</p>
<h2 id="IE和DOM事件流的区别"><a href="#IE和DOM事件流的区别" class="headerlink" title="IE和DOM事件流的区别"></a>IE和DOM事件流的区别</h2><p>1.事件流的区别 IE采用冒泡型事件 Netscape使用捕获型事件 DOM使用先捕获后冒泡型事件 示例：<br>点击这里<br>冒泡型事件模型： button-&gt;div-&gt;body (IE事件流)<br>捕获型事件模型： body-&gt;div-&gt;button (Netscape事件流)<br>DOM事件模型： body-&gt;div-&gt;button-&gt;button-&gt;div-&gt;body (先捕获后冒泡)<br>2.事件侦听函数的区别<br>IE使用:<br>[Object].attachEvent(“name_of_event_handler”, fnHandler); //绑定函数<br>[Object].detachEvent(“name_of_event_handler”, fnHandler); //移除绑定<br>DOM使用：<br>[Object].addEventListener(“name_of_event”, fnHandler, bCapture); //绑定函数<br>[Object].removeEventListener(“name_of_event”, fnHandler, bCapture); //移除绑定<br>bCapture参数用于设置事件绑定的阶段，true为捕获阶段，false为冒泡阶段。</p>
<h2 id="IE和标准下有哪些兼容性的写法"><a href="#IE和标准下有哪些兼容性的写法" class="headerlink" title="IE和标准下有哪些兼容性的写法"></a>IE和标准下有哪些兼容性的写法</h2>   <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">Var</span> <span class="string">ev</span> <span class="string">=</span> <span class="string">ev</span> <span class="string">||</span> <span class="string">window.event</span></span><br><span class="line"><span class="string">document.documentElement.clientWidth</span> <span class="string">||</span> <span class="string">document.body.clientWidth</span></span><br><span class="line"><span class="string">Var</span> <span class="string">target</span> <span class="string">=</span> <span class="string">ev.srcElement||ev.target</span></span><br></pre></td></tr></table></figure>
<h2 id="ajax请求的时候get-和post方式的区别"><a href="#ajax请求的时候get-和post方式的区别" class="headerlink" title="ajax请求的时候get 和post方式的区别"></a>ajax请求的时候get 和post方式的区别</h2><ol>
<li>GET请求会将参数跟在URL后进行传递，而POST请求则是作为HTTP消息的实体内容发送给WEB服务器。当然在Ajax请求中，这种区别对用户是不可见的。</li>
</ol>
<ol start="2">
<li>首先是”GET方式提交的数据最多只能是1024字节”，因为GET是通过URL提交数据，那么GET可提交的数据量就跟URL的长度有直接关系了。而实际上，URL不存在参数上限的问题，HTTP协议规范没有对URL长度进行限制。这个限制是特定的浏览器及服务器对它的限制。IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系统的支持。注意这是限制是整个URL长度，而不仅仅是你的参数值数据长度。</li>
</ol>
<ol start="3">
<li>GET方式请求的数据会被浏览器缓存起来，因此其他人就可以从浏览器的历史记录中读取到这些数据，例如账号和密码等。在某种情况下，GET方式会带来严重的安全问题。而POST方式相对来说就可以避免这些问题。</li>
</ol>
<p>get请求和post请求在服务器端的区别:</p>
<ol start="4">
<li>在客户端使用get请求时,服务器端使用Request.QueryString来获取参数,而客户端使用post请求时,服务器端使用Request.Form来获取参数.</li>
</ol>
<p>HTTP标准包含这两种方法是为了达到不同的目的。POST用于创建资源，资源的内容会被编入HTTP请示的内容中。例如，处理订货表单、在数据库中加入新数据行等。</p>
<p>当请求无副作用时（如进行搜索），便可使用GET方法；当请求有副作用时（如添加数据行），则用POST方法。一个比较实际的问题是：GET方法可能会产生很长的URL，或许会超过某些浏览器与服务器对URL长度的限制。</p>
<p>若符合下列任一情况，则用POST方法：</p>
<ul>
<li>请求的结果有持续性的副作用，例如，数据库内添加新的数据行。</li>
<li>若使用GET方法，则表单上收集的数据可能让URL过长。</li>
<li>要传送的数据不是采用7位的ASCII编码。</li>
</ul>
<p>若符合下列任一情况，则用GET方法：</p>
<ul>
<li>请求是为了查找资源，HTML表单数据仅用来帮助搜索。</li>
<li>请求结果无持续性的副作用。</li>
<li>收集的数据及HTML表单内的输入字段名称的总长不超过1024个字符。</li>
</ul>
<h2 id="call和apply的区别"><a href="#call和apply的区别" class="headerlink" title="call和apply的区别"></a>call和apply的区别</h2><p>一直都没太明白apply()与call()的具体使用原理，今日闲来无事，决定好好研究一番。</p>
<p>JavaScript中的每一个Function对象都有一个apply()方法和一个call()方法，它们的语法分别为：</p>
<p>/<em>apply()方法</em>/<br>   <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">function.apply(thisObj[,</span> <span class="string">argArray])</span></span><br></pre></td></tr></table></figure></p>
<p>/<em>call()方法</em>/<br>   <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">function.call(thisObj[,</span> <span class="string">arg1[,</span> <span class="string">arg2[,</span> <span class="string">[,...argN]]]]);</span></span><br></pre></td></tr></table></figure></p>
<p>它们各自的定义：</p>
<p>apply：调用一个对象的一个方法，用另一个对象替换当前对象。例如：B.apply(A, arguments);即A对象应用B对象的方法。</p>
<p>call：调用一个对象的一个方法，用另一个对象替换当前对象。例如：B.call(A, args1,args2);即A对象调用B对象的方法。</p>
<p>它们的共同之处：</p>
<p>都“可以用来代替另一个对象调用一个方法，将一个函数的对象上下文从初始的上下文改变为由thisObj指定的新对象”。</p>
<p>它们的不同之处：</p>
<p>apply：最多只能有两个参数——新this对象和一个数组argArray。如果给该方法传递多个参数，则把参数都写进这个数组里面，当然，即使只有一个参数，也要写进数组里。如果argArray不是一个有效的数组或arguments对象，那么将导致一个TypeError。如果没有提供argArray和thisObj任何一个参数，那么Global对象将被用作thisObj，并且无法被传递任何参数。</p>
<p>call：它可以接受多个参数，第一个参数与apply一样，后面则是一串参数列表。这个方法主要用在js对象各方法相互调用的时候，使当前this实例指针保持一致，或者在特殊情况下需要改变this指针。如果没有提供thisObj参数，那么 Global 对象被用作thisObj。</p>
<p>实际上，apply和call的功能是一样的，只是传入的参数列表形式不同。</p>
<p>示例代码：</p>
<p>（1）基本用法<br>    <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">function</span> <span class="string">add(a,b)&#123;</span></span><br><span class="line">  <span class="string">return</span> <span class="string">a+b;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">function</span> <span class="string">sub(a,b)&#123;</span></span><br><span class="line">  <span class="string">return</span> <span class="string">a-b;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">var</span> <span class="string">a1</span> <span class="string">=</span> <span class="string">add.apply(sub,[4,2]);</span>　　<span class="string">//sub调用add的方法</span></span><br><span class="line"><span class="string">var</span> <span class="string">a2</span> <span class="string">=</span> <span class="string">sub.apply(add,[4,2]);</span></span><br><span class="line"><span class="string">alert(a1);</span>  <span class="string">//6</span></span><br><span class="line"><span class="string">alert(a2);</span>  <span class="string">//2</span></span><br></pre></td></tr></table></figure></p>
<p>/<em>call的用法</em>/<br>    <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">var</span> <span class="string">a1</span> <span class="string">=</span> <span class="string">add.call(sub,4,2);</span></span><br></pre></td></tr></table></figure></p>
<p>（2）实现继承</p>
<pre><code><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">function</span> <span class="string">Animal(name)&#123;</span></span><br><span class="line">  <span class="string">this.name</span> <span class="string">=</span> <span class="string">name;</span></span><br><span class="line">  <span class="string">this.showName</span> <span class="string">=</span> <span class="string">function()&#123;</span></span><br><span class="line">        <span class="string">alert(this.name);</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="string">function</span> <span class="string">Cat(name)&#123;</span></span><br><span class="line">  <span class="string">Animal.apply(this,[name]);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="string">var</span> <span class="string">cat</span> <span class="string">=</span> <span class="string">new</span> <span class="string">Cat("咕咕");</span></span><br><span class="line"><span class="string">cat.showName();</span></span><br></pre></td></tr></table></figure>
</code></pre><p>/<em>call的用法</em>/<br>Animal.call(this,name);<br> （3）多重继承<br>    <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">function</span> <span class="string">Class10()&#123;</span></span><br><span class="line">  <span class="string">this.showSub</span> <span class="string">=</span> <span class="string">function(a,b)&#123;</span></span><br><span class="line">        <span class="string">alert(a</span> <span class="bullet">-</span> <span class="string">b);</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="string">function</span> <span class="string">Class11()&#123;</span></span><br><span class="line">  <span class="string">this.showAdd</span> <span class="string">=</span> <span class="string">function(a,b)&#123;</span></span><br><span class="line">        <span class="string">alert(a</span> <span class="string">+</span> <span class="string">b);</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="string">function</span> <span class="string">Class12()&#123;</span></span><br><span class="line">  <span class="string">Class10.apply(this);</span></span><br><span class="line">  <span class="string">Class11.apply(this);</span></span><br><span class="line">  <span class="string">//</span> <span class="string">Class10.call(this);</span></span><br><span class="line">  <span class="string">//Class11.call(this);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="string">var</span> <span class="string">c2</span> <span class="string">=</span> <span class="string">new</span> <span class="string">Class12();</span></span><br><span class="line"><span class="string">c2.showSub(3,1);</span>    <span class="string">//2</span></span><br><span class="line"><span class="string">c2.showAdd(3,1);</span>    <span class="string">//4</span></span><br></pre></td></tr></table></figure></p>
<p>apply的一些其他巧妙用法</p>
<p>（1）Math.max 可以实现得到数组中最大的一项：</p>
<p>因为Math.max不支持Math.max([param1,param2])也就是数组，但是它支持Math.max(param1,param2…)，所以可以根据apply的特点来解决 var max=Math.max.apply(null,array)，这样就轻易的可以得到一个数组中的最大项（apply会将一个数组转换为一个参数接一个参</p>
<p>数的方式传递给方法）</p>
<p>这块在调用的时候第一个参数给了null，这是因为没有对象去调用这个方法，我只需要用这个方法帮我运算，得到返回的结果就行，所以直接传递了一个null过去。</p>
<p>用这种方法也可以实现得到数组中的最小项：Math.min.apply(null,array)</p>
<p>（2）Array.prototype.push可以实现两个数组的合并</p>
<p>同样push方法没有提供push一个数组，但是它提供了push(param1,param2…paramN)，同样也可以用apply来转换一下这个数组，即：</p>
<pre><code><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">var</span> <span class="string">arr1=new</span> <span class="string">Array("1","2","3");</span></span><br><span class="line"><span class="string">var</span> <span class="string">arr2=new</span> <span class="string">Array("4","5","6");</span></span><br></pre></td></tr></table></figure>
</code></pre><p>Array.prototype.push.apply(arr1,arr2);    //得到合并后数组的长度，因为push就是返回一个数组的长度<br>也可以这样理解，arr1调用了push方法，参数是通过apply将数组转换为参数列表的集合</p>
<p>通常在什么情况下，可以使用apply类似Math.max等之类的特殊用法：</p>
<p>一般在目标函数只需要n个参数列表，而不接收一个数组的形式，可以通过apply的方式巧妙地解决这个问题。</p>
<h2 id="ajax请求时，如何解析json数据"><a href="#ajax请求时，如何解析json数据" class="headerlink" title="ajax请求时，如何解析json数据"></a>ajax请求时，如何解析json数据</h2><pre><code>使用eval parse 鉴于安全性考虑 使用parse更靠谱
</code></pre><h2 id="写一个获取非行间样式的函数"><a href="#写一个获取非行间样式的函数" class="headerlink" title="写一个获取非行间样式的函数"></a>写一个获取非行间样式的函数</h2><pre><code><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">function</span> <span class="string">getStyle(obj,</span> <span class="string">attr,</span> <span class="string">value)</span> <span class="string">&#123;</span></span><br><span class="line"><span class="string">if(!value)</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="string">if(obj.currentStyle)</span> <span class="string">&#123;</span></span><br><span class="line">        <span class="string">return</span> <span class="string">obj.currentStyle(attr)</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line">    <span class="string">else</span> <span class="string">&#123;</span></span><br><span class="line">        <span class="string">obj.getComputedStyle(attr,</span> <span class="literal">false</span><span class="string">)</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line">    <span class="string">else</span> <span class="string">&#123;</span></span><br><span class="line">        <span class="string">obj.style[attr]=value</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
</code></pre><h2 id="事件委托-代理-是什么"><a href="#事件委托-代理-是什么" class="headerlink" title="事件委托(代理)是什么"></a>事件委托(代理)是什么</h2><p>让利用事件冒泡的原理，让自己的所触发的事件，让他的父元素代替执行！</p>
<h2 id="闭包是什么，有什么特性，对页面有什么影响"><a href="#闭包是什么，有什么特性，对页面有什么影响" class="headerlink" title="闭包是什么，有什么特性，对页面有什么影响"></a>闭包是什么，有什么特性，对页面有什么影响</h2><p>“官方”的解释是：所谓“闭包”，指的是一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。</p>
<p>通俗的讲：就是函数a的内部函数b，被函数a外部的一个变量引用的时候，就创建了一个闭包。</p>
<p>（这样在执行完var c=a()后，变量c实际上是指向了函数b，再执行c()后就会弹出一个窗口显示i的值(第一次为1)。这段代码其实就创建了一个闭包，为什么？因为函数a外的变量c引用了函数a内的函数b）</p>
   <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">function</span> <span class="string">a()&#123;</span></span><br><span class="line">       <span class="string">var</span> <span class="string">i=0;</span></span><br><span class="line">       <span class="string">function</span> <span class="string">b()&#123;</span></span><br><span class="line">     <span class="string">alert(++i);</span></span><br><span class="line">   <span class="string">&#125;</span></span><br><span class="line">  <span class="string">return</span> <span class="string">b;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line">     <span class="string">var</span> <span class="string">c</span> <span class="string">=</span> <span class="string">a();</span></span><br><span class="line"><span class="string">c();</span></span><br></pre></td></tr></table></figure>
<p>闭包的特性：</p>
<p>①.封闭性：外界无法访问闭包内部的数据，如果在闭包内声明变量，外界是无法访问的，除非闭包主动向外界提供访问接口；<br>②.持久性：一般的函数，调用完毕之后，系统自动注销函数，而对于闭包来说，在外部函数被调用之后，闭包结构依然保存在<br>系统中，闭包中的数据依然存在，从而实现对数据的持久使用。</p>
<p>优点：</p>
<p>① 减少全局变量。</p>
<p>② 减少传递函数的参数量</p>
<p>③ 封装；</p>
<p>缺点：<br> 使用闭包会占有内存资源，过多的使用闭包会导致内存溢出等.</p>
<pre><code>(1)、使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，
缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。

(2)、闭包有三个特性：
    a、函数嵌套函数
    b、函数内部可以引用外部的参数和变量
    c、参数和变量不会被垃圾回收机制回收
</code></pre><h2 id="如何阻止事件冒泡和默认事件"><a href="#如何阻止事件冒泡和默认事件" class="headerlink" title="如何阻止事件冒泡和默认事件"></a>如何阻止事件冒泡和默认事件</h2><p>stoppropagation / preventdefault</p>
<h2 id="解释jsonp的原理，以及为什么不是真正的ajax"><a href="#解释jsonp的原理，以及为什么不是真正的ajax" class="headerlink" title="解释jsonp的原理，以及为什么不是真正的ajax"></a>解释jsonp的原理，以及为什么不是真正的ajax</h2><ol>
<li>jsonp的原理:就是利用浏览器可以动态地插入一段js并执行的特点完成的。</li>
<li>为什么不是真正的 ajax?<br> ajax的核心是 ： 通过XmlHttpRequest获取非本页内容，<br> jsonp的核心 ： 动态添加script标签来调用服务器提供的js脚本。</li>
<li>ajax和jsonp的调用方式很像，目的一样，都是请求url，然后把服务器返回的数据进行处理，因此jquery和ext等框架都把jsonp作为ajax的一种形式进行了封装；<br>还是有不同点的：</li>
<li>实质不同<br>　   ajax的核心是通过xmlHttpRequest获取非本页内容<br>　   jsonp的核心是动态添加script标签调用服务器提供的js脚本</li>
<li>ajax通过服务端代理一样跨域,jsonp也不并不排斥同域的数据的获取</li>
<li>jsonp是一种方式或者说非强制性的协议,ajax也不一定非要用json格式来传递数据　</li>
<li>jsonp只支持get请求，ajax支持get和post请求</li>
</ol>
<h2 id="javascript的本地对象，内置对象和宿主对象"><a href="#javascript的本地对象，内置对象和宿主对象" class="headerlink" title="javascript的本地对象，内置对象和宿主对象"></a>javascript的本地对象，内置对象和宿主对象</h2><p>JS中，可以将对象分为“内部对象”、“宿主对象”和“自定义对象”三种。<br>内部对象<br>    js中的内部对象包括Array、Boolean、Date、Function、Global、Math、Number、Object、RegExp、String以及各种错误类对象，包括Error、EvalError、RangeError、ReferenceError、SyntaxError、TypeError。<br>  其中Global和Math这两个对象又被称为“内置对象”，这两个对象在脚本程序初始化时被创建，不必实例化这两个对象。<br>宿主对象<br>    宿主对象就是执行JS脚本的环境提供的对象。对于嵌入到网页中的JS来说，其宿主对象就是浏览器提供的对象，所以又称为浏览器对象，如IE、Firefox等浏览器提供的对象。不同的浏览器提供的宿主对象可能不同，即使提供的对象相同，其实现方式也大相径庭！这会带来浏览器兼容问题，增加开发难度。<br>浏览器对象有很多，如Window和Document等等。<br>自定义对象<br>  顾名思义，就是开发人员自己定义的对象。JS允许使用自定义对象，使JS应用及功能得到扩充<br>背诵<br>内部对象/本地对象<br>    定义：与宿主无关的对象，ECMA-262 （规则）定义的类（引用类型）<br>    本地对象：Array、Boolean、Date、Function、Global、Math、Number、Object、RegExp、String以及各种错误类对象，包括Error、EvalError、RangeError、ReferenceError、SyntaxError、TypeError。(16个)<br>    内置对象：其中Global和Math这两个对象又被称为“内置对象”。<br>    区别：普通本地对象/内部对象需要实例化，内置对象不需要实例化。<br>宿主对象/浏览器对象：<br>    定义：执行JS脚本的环境（宿主）提供的对象。<br>    特点：依赖于宿主，带来浏览器兼容问题，增加开发难度。<br>    浏览器对象有很多，如Window和Document等等。<br>自定义对象<br>    开发人员自己定义的对象。</p>
<h2 id="document-load-和document-ready的区别"><a href="#document-load-和document-ready的区别" class="headerlink" title="document load 和document ready的区别"></a>document load 和document ready的区别</h2><p>页面加载完成有两种事件：<br>一.是ready，表示文档结构已经加载完成（不包含图片等非文字媒体文件）。<br>二.是onload，指示页面包含图片等文件在内的所有元素都加载完成。</p>
<h2 id="”-”和“-”的不同"><a href="#”-”和“-”的不同" class="headerlink" title="”==”和“===”的不同"></a>”==”和“===”的不同</h2><p>前者会自动转换类型<br>后者不会</p>
<h2 id="javascript的同源策略"><a href="#javascript的同源策略" class="headerlink" title="javascript的同源策略"></a>javascript的同源策略</h2><p>同源策略是一个很重要的安全理念，它在保证数据的安全性方面有着重要的意义，<br>一段脚本只能读取来自于同一来源的窗口和文档的属性，这里的同一来源指的是协议、域名和端口号的组合</p>
<h2 id="最快捷的数组求最大值"><a href="#最快捷的数组求最大值" class="headerlink" title="最快捷的数组求最大值"></a>最快捷的数组求最大值</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr = [ 1,5,1,7,5,9];</span><br><span class="line">Math.max(...arr)  // 9</span><br></pre></td></tr></table></figure>
<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><p>升序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var numberArray = [3,6,2,4,1,5];</span><br><span class="line">numberArray.sort(function(a,b)&#123;</span><br><span class="line">   return a-b;</span><br><span class="line">&#125;)</span><br><span class="line">console.log(numberArray);</span><br></pre></td></tr></table></figure></p>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var examplearr=[8,94,15,88,55,76,21,39];</span><br><span class="line">function sortarr(arr)&#123;</span><br><span class="line">    for(i=0;i&lt;arr.length-1;i++)&#123;</span><br><span class="line">        for(j=0;j&lt;arr.length-1-i;j++)&#123;</span><br><span class="line">            if(arr[j]&gt;arr[j+1])&#123;</span><br><span class="line">                var temp=arr[j];</span><br><span class="line">                arr[j]=arr[j+1];</span><br><span class="line">                arr[j+1]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line">sortarr(examplearr);</span><br><span class="line">console.log(examplearr);</span><br></pre></td></tr></table></figure>
<h2 id="null和undefined的区别："><a href="#null和undefined的区别：" class="headerlink" title="null和undefined的区别："></a>null和undefined的区别：</h2><p>ull：表示无值；undefined：表示一个未声明的变量，或已声明但没有赋值的变量，<br>或一个并不存在的对象属性。</p>
<h2 id="使用闭包的注意点："><a href="#使用闭包的注意点：" class="headerlink" title="使用闭包的注意点："></a>使用闭包的注意点：</h2><p>1.由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</p>
<p>2.闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。<br>（关于闭包，详细了解请看JavaScript之作用域与闭包详解）</p>
<h2 id="请解释变量声明提升"><a href="#请解释变量声明提升" class="headerlink" title="请解释变量声明提升"></a>请解释变量声明提升</h2><p>在函数执行时，把变量的声明提升到了函数顶部，而其值定义依然在原来位置</p>
<h2 id="如何从浏览器的URL中获取查询字符串参数"><a href="#如何从浏览器的URL中获取查询字符串参数" class="headerlink" title="如何从浏览器的URL中获取查询字符串参数"></a>如何从浏览器的URL中获取查询字符串参数</h2><p>以下函数把获取一个key的参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function parseQueryString ( name )&#123;</span><br><span class="line">      name = name.replace(/[\[]/,&quot;\\\[&quot;);</span><br><span class="line">      var regexS = &quot;[\\?&amp;]&quot;+name+&quot;=([^&amp;#]*)&quot;;</span><br><span class="line">      var regex = new RegExp( regexS );</span><br><span class="line">      var results = regex.exec( window.location.href );</span><br><span class="line"></span><br><span class="line">      if(results == null) &#123;</span><br><span class="line">          return &quot;&quot;;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">     return results[1];</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="arguments是什么？"><a href="#arguments是什么？" class="headerlink" title="arguments是什么？"></a>arguments是什么？</h2><p>rguments虽然有一些数组的性质，但其并非真正的数组，只是一个类数组对象。<br>其并没有数组的很多方法，不能像真正的数组那样调用.jion(),.concat(),.pop()等方法。</p>
<h2 id="什么是”use-strict”-使用它的好处和坏处分别是什么"><a href="#什么是”use-strict”-使用它的好处和坏处分别是什么" class="headerlink" title="什么是”use strict”;?使用它的好处和坏处分别是什么"></a>什么是”use strict”;?使用它的好处和坏处分别是什么</h2><p>在代码中出现表达式-“use strict”; 意味着代码按照严格模式解析，这种模式使得Javascript在更严格的条件下运行。<br>好处：<br>    1.消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;<br>    2.消除代码运行的一些不安全之处，保证代码运行的安全；<br>    3.提高编译器效率，增加运行速度；<br>坏处：<br>    1.同样的代码，在”严格模式”中，可能会有不一样的运行结果；一些在”正常模式”下可以运行的语句，在”严格模式”下将不能运行。</p>
<h2 id="什么是回调函数"><a href="#什么是回调函数" class="headerlink" title="什么是回调函数"></a>什么是回调函数</h2><p>1.就是一个函数的调用过程。那么就从理解这个调用过程开始吧。<br>函数a有一个参数，这个参数是个函数b，当函数a执行完以后执行函数b。那么这个过程就叫回调。<br>2.另外种解释：开发网站的过程中，我们经常遇到某些耗时很长的javascript操作。其中，既有异步的操作（比如ajax读取服务器数据），也有同步的操作（比如遍历一个大型数组），它们都不是立即能得到结果的。<br>通常的做法是，为它们指定回调函数（callback）。即事先规定，一旦它们运行结束，应该调用哪些函数。</p>
<h2 id="使用-typeof-bar-“object”-判断-bar-是不是一个对象有神马潜在的弊端？如何避免这种弊端？"><a href="#使用-typeof-bar-“object”-判断-bar-是不是一个对象有神马潜在的弊端？如何避免这种弊端？" class="headerlink" title="使用 typeof bar === “object” 判断 bar 是不是一个对象有神马潜在的弊端？如何避免这种弊端？"></a>使用 typeof bar === “object” 判断 bar 是不是一个对象有神马潜在的弊端？如何避免这种弊端？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;&#125;;</span><br><span class="line">let arr = [];</span><br><span class="line"></span><br><span class="line">console.log(typeof obj === &apos;object&apos;);  //true</span><br><span class="line">console.log(typeof arr === &apos;object&apos;);  //true</span><br></pre></td></tr></table></figure>
<p>从上面的输出结果可知，typeof bar === “object” 并不能准确判断 bar 就是一个 Object。可以通过 Object.prototype.toString.call(bar) === “[object Object]” 来避免这种弊端：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;&#125;;</span><br><span class="line">let arr = [];</span><br><span class="line"></span><br><span class="line">console.log(Object.prototype.toString.call(obj));  //[object Object]</span><br><span class="line">console.log(Object.prototype.toString.call(arr));  //[object Array]</span><br></pre></td></tr></table></figure></p>
<h2 id="下面的代码会输出什么？为什么？"><a href="#下面的代码会输出什么？为什么？" class="headerlink" title="下面的代码会输出什么？为什么？"></a>下面的代码会输出什么？为什么？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">console.log(1 +  &quot;2&quot; + &quot;2&quot;); //122</span><br><span class="line">console.log(1 +  +&quot;2&quot; + &quot;2&quot;); //32</span><br><span class="line">console.log(1 +  -&quot;1&quot; + &quot;2&quot;); //02</span><br><span class="line">console.log(+&quot;1&quot; +  &quot;1&quot; + &quot;2&quot;); //112</span><br><span class="line">console.log( &quot;A&quot; - &quot;B&quot; + &quot;2&quot;); //NaN2</span><br><span class="line">console.log( &quot;A&quot; - &quot;B&quot; + 2); //NaN</span><br><span class="line">console.log(&apos;3&apos; + 2 + 1);//321</span><br><span class="line">console.log(typeof +&apos;3&apos;);  //number</span><br><span class="line">console.log(typeof (&apos;&apos;+3));  //string</span><br><span class="line">console.log(&apos;a&apos; * &apos;sd&apos;);   //NaN</span><br></pre></td></tr></table></figure>
<h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h2><pre><code>或逻辑时：当0在前面时console.log((0|| 2));则输出为后面的数，为2；
当除0以为的数在前面时console.log((2|| 0));则输出为2；


与逻辑时：当只要有0时console.log(0&amp;&amp;2 );则输出都为0；


当不存在0时，console.log(1&amp;&amp;2 );则输出都为后面的一个，为2；
console.log(2&amp;&amp;1 );则输出为1；
</code></pre><h2 id="在-JavaScript，常见的-false-值"><a href="#在-JavaScript，常见的-false-值" class="headerlink" title="在 JavaScript，常见的 false 值"></a>在 JavaScript，常见的 false 值</h2><p>0, ‘0’, +0, -0, false, ‘’,null,undefined,null,NaN<br>要注意空数组([])和空对象({}):</p>
<pre><code>console.log([] == false) //true
console.log({} == false) //false
console.log(Boolean([])) //true
</code></pre><h2 id="解释下面代码的输出"><a href="#解释下面代码的输出" class="headerlink" title="解释下面代码的输出"></a>解释下面代码的输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a=&#123;&#125;,</span><br><span class="line">b=&#123;key:&apos;b&apos;&#125;,</span><br><span class="line">c=&#123;key:&apos;c&apos;&#125;;</span><br><span class="line">a[b]=123;</span><br><span class="line">a[c]=456;</span><br><span class="line">console.log(a[b]);</span><br></pre></td></tr></table></figure>
<pre><code>因为在设置对象属性时，JS将隐式地stringify参数值。
在本例中，由于b和c都是对象，它们都将被转换为“[object object]”。
因此，a[b]和[c]都等价于[[object object]]，并且可以互换使用。
所以，设置或引用[c]与设置或引用a[b]完全相同。`
</code></pre><h2 id="解释下面代码的输出-1"><a href="#解释下面代码的输出-1" class="headerlink" title="解释下面代码的输出"></a>解释下面代码的输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(function(x) &#123;</span><br><span class="line">    return (function(y) &#123;</span><br><span class="line">        console.log(x);</span><br><span class="line">    &#125;)(2)</span><br><span class="line">&#125;)(1);</span><br></pre></td></tr></table></figure>
<pre><code>输出1，闭包能够访问外部作用域的变量或参数。
</code></pre><h2 id="请写出以下输出结果"><a href="#请写出以下输出结果" class="headerlink" title="请写出以下输出结果"></a>请写出以下输出结果</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function Foo() &#123;</span><br><span class="line">    getName = function () &#123; alert (1); &#125;;</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br><span class="line">Foo.getName = function () &#123; alert (2);&#125;;</span><br><span class="line">Foo.prototype.getName = function () &#123; alert (3);&#125;;</span><br><span class="line">var getName = function () &#123; alert (4);&#125;;</span><br><span class="line">function getName() &#123; alert (5);&#125;</span><br><span class="line"></span><br><span class="line">Foo.getName(); //2</span><br><span class="line">getName(); //4</span><br><span class="line">Foo().getName(); //1</span><br><span class="line">getName(); //1</span><br><span class="line">new Foo.getName(); //2</span><br><span class="line">new Foo().getName(); //3</span><br><span class="line">new new Foo().getName(); //3</span><br></pre></td></tr></table></figure>
<h2 id="谈谈你对Ajax的理解？-概念、特点、作用"><a href="#谈谈你对Ajax的理解？-概念、特点、作用" class="headerlink" title="谈谈你对Ajax的理解？(概念、特点、作用)"></a>谈谈你对Ajax的理解？(概念、特点、作用)</h2><p>AJAX全称为“Asynchronous JavaScript And XML”（异步JavaScript和XML）是指一种创建交互式网页应用的开发技术、改善用户体验，实现无刷新效果。</p>
<p>优点</p>
<pre><code>a、不需要插件支持
b、优秀的用户体验
c、提高Web程序的性能
d、减轻服务器和带宽的负担
</code></pre><p>缺点</p>
<pre><code>a、破坏浏览器“前进”、“后退”按钮的正常功能，可以通过简单的插件弥补
b、对搜索引擎的支持不足
</code></pre><h2 id="说说你对延迟对象deferred的理解"><a href="#说说你对延迟对象deferred的理解" class="headerlink" title="说说你对延迟对象deferred的理解"></a>说说你对延迟对象deferred的理解</h2><p>a、什么是deferred对象</p>
<pre><code>在回调函数方面，jQuery的功能非常弱。为了改变这一点，jQuery开发团队就设计了deferred对象。
简单说，deferred对象就是jQuery的回调函数解决方案。在英语中，defer的意思是”延迟”，所以deferred对象的含义就是”延迟”到未来某个点再执行。
它解决了如何处理耗时操作的问题，对那些操作提供了更好的控制，以及统一的编程接口。
</code></pre><p>b、它的主要功能，可以归结为四点：</p>
<pre><code>(1)、实现链式操作
(2)、指定同一操作的多个回调函数
(3)、为多个操作指定回调函数
(4)、普通操作的回调函数接口
</code></pre><h2 id="什么是跨域，如何实现跨域访问"><a href="#什么是跨域，如何实现跨域访问" class="headerlink" title="什么是跨域，如何实现跨域访问?"></a>什么是跨域，如何实现跨域访问?</h2><p>跨域是指不同域名之间相互访问。<br>JavaScript同源策略的限制，A域名下的JavaScript无法操作B或是C域名下的对象</p>
<p>实现：</p>
<p>(1)、JSONP跨域：利用script脚本允许引用不同域下的js实现的，将回调方法带入服务器，返回结果时回调。</p>
<pre><code>1 通过jsonp跨域
&lt;script&gt;
    var script = document.createElement(&apos;script&apos;);
    script.type = &apos;text/javascript&apos;;

    // 传参并指定回调执行函数为onBack
    script.src = &apos;http://www.....:8080/login?user=admin&amp;callback=onBack&apos;;
    document.head.appendChild(script);

    // 回调执行函数
    function onBack(res) {
        alert(JSON.stringify(res));
    }
 &lt;/script&gt;
2.document.domain + iframe跨域
    此方案仅限主域相同，子域不同的跨域应用场景。
    1.父窗口：(http://www.domain.com/a.html)

  &lt;iframe id=&quot;iframe&quot; src=&quot;http://child.domain.com/b.html&quot;&gt;&lt;/iframe&gt;
        &lt;script&gt;
            document.domain = &apos;domain.com&apos;;
            var user = &apos;admin&apos;;
        &lt;/script&gt;
            2.子窗口：(http://child.domain.com/b.html)

  &lt;script&gt;
            document.domain = &apos;domain.com&apos;;
            // 获取父窗口中变量
            alert(&apos;get js data from parent ---&gt; &apos; + window.parent.user);
        &lt;/script&gt;
弊端：请看下面渲染加载优化

1、 nginx代理跨域
2、 nodejs中间件代理跨域
3、 后端在头部信息里面设置安全域名
</code></pre><p>(3)、跨域资源共享（CORS）<br>跨域资源共享（CORS）是一种网络浏览器的技术规范，它为Web服务器定义了一种方式，允许网页从不同的域访问其资源。</p>
<p>CORS与JSONP相比:</p>
<pre><code>a、JSONP只能实现GET请求，而CORS支持所有类型的HTTP请求。
b、使用CORS，开发者可以使用普通的XMLHttpRequest发起请求和获得数据，比起JSONP有更好的错误处理。
c、JSONP主要被老的浏览器支持，它们往往不支持CORS，而绝大多数现代浏览器都已经支持了CORS。
</code></pre><h2 id="为什么要使用模板引擎"><a href="#为什么要使用模板引擎" class="headerlink" title="为什么要使用模板引擎"></a>为什么要使用模板引擎</h2><p>a.模板引擎（这里特指用于Web开发的模板引擎）是为了使用户界面与业务数据（内容）分离而产生的，它可以生成特定格式的文档，用于网站的模板引擎就会生成一个标准的HTML文档。<br>b.在一些示例中javascript有大量的html字符串，html中有一些像onclick样的javascript，这样javascript中有html，html中有javascript，代码的偶合度很高，不便于修改与维护，使用模板引擎可以解决问题。</p>
<h2 id="根据你的理解-请简述JavaScript脚本的执行原理"><a href="#根据你的理解-请简述JavaScript脚本的执行原理" class="headerlink" title="根据你的理解,请简述JavaScript脚本的执行原理"></a>根据你的理解,请简述JavaScript脚本的执行原理</h2><p>JavaScript是一种动态、弱类型、基于原型的语言，通过浏览器可以直接执行。<br>当浏览器遇到script标记的时候，浏览器会执行之间的javascript代码。嵌入的js代码是顺序执行的，每个脚本定义的全局变量和函数，都可以被后面执行的脚本所调用。 变量的调用，必须是前面已经声明，否则获取的变量值是undefined。</p>
<h2 id="JavaScript的数据类型有哪些"><a href="#JavaScript的数据类型有哪些" class="headerlink" title="JavaScript的数据类型有哪些"></a>JavaScript的数据类型有哪些</h2><pre><code>基本数据类型：字符串 String、数字 Number、布尔Boolean
复合数据类型：数组 Array、对象 Object
特殊数据类型：Null 空对象、Undefined 未定义
</code></pre><h2 id="谈谈你This对象的理解"><a href="#谈谈你This对象的理解" class="headerlink" title="谈谈你This对象的理解"></a>谈谈你This对象的理解</h2><p>回答一：</p>
<p>(1)、js的this指向是不确定的，也就是说是可以动态改变的。call/apply 就是用于改变this指向的函数，这样设计可以让代码更加灵活，复用性更高<br>(2)、this 一般情况下，都是指向函数的拥有者。<br>(3)、在函数自执行里，this 指向的是 window 对象。</p>
<pre><code>扩展：关于this，还有一个地方比较让人模糊的是在dom事件里，通常有如下3种情况：
a、使用标签属性注册事件，此时this指向的是window对象。
b、对与a，要让this指向input，可以将this作为参数传递。
c、使用addEventListener等注册事件。此时this也是指向 input。
</code></pre><p>(1)、处于全局作用域下的this：</p>
<p>this;/<em>window</em>/<br>var a = {name: this}/<em>window</em>/<br>var b = [this];/<em>window</em>/<br>在全局作用域下，this默认指向window对象。</p>
<p>(2)、处在函数中的this，又分为以下几种情况：<br>a、一般定义的函数，然后一般的执行：</p>
<pre><code>var a = function(){
console.log(this);
}
a();/*window*/
this还是默认指向window。
</code></pre><p>b、一般定义，用new调用执行：</p>
<pre><code>var a = function(){
console.log(this);
}
new a();/*新建的空对象*/
这时候让this指向新建的空对象，我们才可以给空对象初始化自有变量
</code></pre><p>c、作为对象属性的函数，调用时：</p>
<pre><code>var a = {
f:function(){
console.log(this)
}
}
a.f();/*a对象*/
这时候this指向调用f函数的a对象。
</code></pre><p>(3)、通过call()和apply()来改变this的默认引用：</p>
<pre><code>var b = {id: &apos;b&apos;};
var a = {
f:function(){
console.log(this)
　}
}
a.f.call(b);/*window*/
所有函数对象都有的call方法和apply方法，它们的用法大体相似，f.call(b);的意思 是，执行f函数，并将f函数执行期活动对象里的this指向b对象，这样标示符解析时，this就会是b对象了。不过调用函数是要传参的。所以，f.call(b, x, y); f.apply(b, [x, y]);好吧，以上就是用call方法执行f函数，与用apply方法执行f函数时传参方式，它们之间的差异，大家一目了然：apply通过数组的方式传递参数，call通过一个个的形参传递参数。
</code></pre><p>(4)、一些函数特殊执行情况this的指向问题：</p>
<p>a、setTimeout()和setInverval():</p>
<pre><code>var a = function(){
console.log(this);
}
setTimeout(a,0);/*window*/
setInterval()类似。
</code></pre><p>b、dom模型中触发事件的回调方法执行中活动对象里的this指向该dom对象。</p>
<h2 id="JavaScript对象的几种创建方式"><a href="#JavaScript对象的几种创建方式" class="headerlink" title="JavaScript对象的几种创建方式?"></a>JavaScript对象的几种创建方式?</h2><p>(1) 工厂模式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Parent()&#123;</span><br><span class="line">    var Child = new Object();</span><br><span class="line">    Child.name=&quot;欲泪成雪&quot;;</span><br><span class="line">    Child.age=&quot;20&quot;;</span><br><span class="line">    return Child;</span><br><span class="line">&#125;;</span><br><span class="line">var x = Parent();</span><br></pre></td></tr></table></figure></p>
<pre><code>引用该对象的时候，这里使用的是 var x = Parent()而不是 var x = new Parent();因为后者会可能出现
很多问题（前者也成为工厂经典方式,后者称之为混合工厂方式），不推荐使用new的方式使用该对象
</code></pre><p>(2)构造函数方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function Parent()&#123;</span><br><span class="line">　　this.name=&quot;欲泪成雪&quot;;</span><br><span class="line">　　this.age=&quot;20&quot;;</span><br><span class="line">&#125;;</span><br><span class="line">var x =new Parent();</span><br></pre></td></tr></table></figure></p>
<p>(3) 原型模式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function Parent()&#123;</span><br><span class="line">&#125;;</span><br><span class="line">Parent.prototype.name=&quot;欲泪成雪&quot;;</span><br><span class="line">Parent.prototype.age=&quot;20&quot;;</span><br><span class="line">var x =new Parent();</span><br></pre></td></tr></table></figure></p>
<p>(4)混合的构造函数，原型方式（推荐）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Parent()&#123;</span><br><span class="line">　　this.name=&quot;欲泪成雪&quot;;</span><br><span class="line">　　this.age=22;</span><br><span class="line">&#125;;</span><br><span class="line">Parent.prototype.lev=function()&#123;</span><br><span class="line">　　return this.name;</span><br><span class="line">&#125;;</span><br><span class="line">var x =new Parent();</span><br></pre></td></tr></table></figure></p>
<p>(5)动态原型方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Parent()&#123;</span><br><span class="line">　　this.name=&quot;欲泪成雪&quot;;</span><br><span class="line">　　this.age=22;</span><br><span class="line">;</span><br><span class="line">if(typeof Parent._lev==&quot;undefined&quot;)&#123;</span><br><span class="line">Parent.prototype.lev=function()&#123;</span><br><span class="line">　　return this.name;</span><br><span class="line">&#125;</span><br><span class="line">Parent._lev=true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">var x =new Parent();</span><br></pre></td></tr></table></figure></p>
<h2 id="请写出js内存泄漏的问题"><a href="#请写出js内存泄漏的问题" class="headerlink" title="请写出js内存泄漏的问题?"></a>请写出js内存泄漏的问题?</h2><p>回答一：</p>
<p>(1)、IE7/8 DOM循环引用导致内存泄漏</p>
<pre><code>a、多个对象循环引用
b、循环引用自己
</code></pre><p>(2)、基础的DOM泄漏</p>
<pre><code>当原有的DOM被移除时，子结点引用没有被移除则无法回收。
</code></pre><p>(3)、timer定时器泄漏</p>
<pre><code>这个时候你无法回收buggyObject,解决办法，先停止timer然后再回收
</code></pre><p>回答二：</p>
<pre><code>内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。
垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。

setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。
闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）也会引发内存泄漏问题。
</code></pre><h2 id="JS应该放在什么位置？"><a href="#JS应该放在什么位置？" class="headerlink" title="JS应该放在什么位置？"></a>JS应该放在什么位置？</h2><p>a、在一个对象上触发某类事件（比如单击onclick事件），如果此对象定义了此事件的处理程序，那么此事件就会调用这个处理程序，如果没有定义此事件处理程序或者事件返回true，那么这个事件会向这个对象的父级对象传播，从里到外，直至它被处理（父级对象所有同类事件都将被激活），或者它到达了对象层次的最顶层，即document对象（有些浏览器是window）。</p>
<p>b、冒泡型事件：事件按照从最特定的事件目标到最不特定的事件目标(document对象)的顺序触发</p>
<p>c、js冒泡机制是指如果某元素定义了事件A，如click事件，如果触发了事件之后，没有阻止冒泡事件，那么事件将向父级元素传播，触发父类的click函数。</p>
<p>//阻止冒泡时间方法，兼容ie(e.cancleBubble)和ff(e.stopProgation)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function stopBubble(e)&#123;</span><br><span class="line">var evt = e||window.event;</span><br><span class="line">evt.stopPropagation?evt.stopPropagation():(evt.cancelBubble=true);//阻止冒泡</span><br><span class="line">evt.preventDefault</span><br></pre></td></tr></table></figure></p>
<h2 id="说说你对Promise的理解"><a href="#说说你对Promise的理解" class="headerlink" title="说说你对Promise的理解?"></a>说说你对Promise的理解?</h2><p>ES6 原生提供了 Promise 对象。<br>所谓 Promise，就是一个对象，用来传递异步操作的消息。它代表了某个未来才会知道结果的事件（通常是一个异步操作），并且这个事件提供统一的 API，可供进一步处理。</p>
<p>Promise 对象有以下两个特点：</p>
<p>(1)、对象的状态不受外界影响。Promise 对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称 Fulfilled）和 Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是 Promise 这个名字的由来，它的英语意思就是「承诺」，表示其他手段无法改变。</p>
<p>(2)、一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise 对象的状态改变，只有两种可能：从 Pending 变为 Resolved 和从 Pending 变为 Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对 Promise 对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。<br>有了 Promise 对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise 对象提供统一的接口，使得控制异步操作更加容易。</p>
<p>Promise 也有一些缺点。首先，无法取消 Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部。第三，当处于 Pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p>
<h2 id="说说你对原型（prototype）理解"><a href="#说说你对原型（prototype）理解" class="headerlink" title="说说你对原型（prototype）理解?"></a>说说你对原型（prototype）理解?</h2><p>使用 typeof 运算符时采用引用类型存储值会出现一个问题，无论引用的是什么类型的对象，它都返回 “object”。ECMAScript 引入了另一个 Java 运算符 instanceof 来解决这个问题。instanceof 运算符与 typeof 运算符相似，用于识别正在处理的对象的类型。与 typeof 方法不同的是，instanceof 方法要求开发者明确地确认对象为某特定类型</p>
<h2 id="纯数组排序"><a href="#纯数组排序" class="headerlink" title="纯数组排序"></a>纯数组排序</h2><p>常见有冒泡和选择,这里利用sort排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export const orderArr=(arr)=&gt;&#123;</span><br><span class="line">    arr.sort((a,b)=&gt;&#123;</span><br><span class="line">        return a-b //将arr升序排列,如果是倒序return -(a-b)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="数组对象排序"><a href="#数组对象排序" class="headerlink" title="数组对象排序"></a>数组对象排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">export const orderArr=(arr)=&gt;&#123;</span><br><span class="line">    arr.sort((a,b)=&gt;&#123;</span><br><span class="line">        let value1 = a[property];</span><br><span class="line">        let value2 = b[property];</span><br><span class="line">        return value1 - value2;//sort方法接收一个函数作为参数，这里嵌套一层函数用</span><br><span class="line">        //来接收对象属性名，其他部分代码与正常使用sort方法相同</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var arr = [</span><br><span class="line">    &#123;name:&apos;zopp&apos;,age:0&#125;,</span><br><span class="line">    &#123;name:&apos;gpp&apos;,age:18&#125;,</span><br><span class="line">    &#123;name:&apos;yjj&apos;,age:8&#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">function compare(property)&#123;</span><br><span class="line">    return function(a,b)&#123;</span><br><span class="line">        var value1 = a[property];</span><br><span class="line">        var value2 = b[property];</span><br><span class="line">        return value1 - value2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(arr.sort(compare(&apos;age&apos;)))</span><br></pre></td></tr></table></figure>
<p>对象遍历<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">export const traverseObj=(obj)=&gt;&#123;</span><br><span class="line">    for(let variable in obj)&#123;</span><br><span class="line">    //For…in遍历对象包括所有继承的属性,所以如果</span><br><span class="line">    //只是想使用对象本身的属性需要做一个判断</span><br><span class="line">        if(obj.hasOwnProperty(variable))&#123;</span><br><span class="line">            console.log(variable,obj[variable])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h2><p>promise是一种封装未来值的易于复用的异步任务管理机制,主要解决地狱回调和控制异步的顺序</p>
<p>1.应用方法一<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">export const promiseDemo=()=&gt;&#123;</span><br><span class="line">    new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        resolve(()=&gt;&#123;</span><br><span class="line">            let a=1;</span><br><span class="line">            return ++a;</span><br><span class="line">        &#125;).then((data)=&gt;&#123;</span><br><span class="line">            console.log(data)//data值为++a的值</span><br><span class="line">        &#125;).catch(()=&gt;&#123;//错误执行这个</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.应用方法二</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export const promiseDemo=()=&gt;&#123;</span><br><span class="line">    Promise.resolve([1,2,3]).then((data)=&gt;&#123;//直接初始化一个Promise并执行resolve方法</span><br><span class="line">        console.log(data)//data值为[1,2,3]</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="如何禁用网页菜单右键？"><a href="#如何禁用网页菜单右键？" class="headerlink" title="如何禁用网页菜单右键？"></a>如何禁用网页菜单右键？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    function Click()&#123;</span><br><span class="line">        window.event.returnValue=false;</span><br><span class="line">    &#125;</span><br><span class="line">    document.oncontextmenu=Click;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">恢复方法：javascript:alert(document.oncontextmenu=&apos;&apos;)</span><br></pre></td></tr></table></figure>
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/03/07/JavaScript 克隆/" rel="next" title="JavaScript 克隆简介">
                <i class="fa fa-chevron-left"></i> JavaScript 克隆简介
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">_doucc</p>
              <div class="site-description motion-element" itemprop="description">没人能在我的BGM里打败我</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">6</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              

              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#javascript的typeof返回哪些数据类型"><span class="nav-number">1.</span> <span class="nav-text">javascript的typeof返回哪些数据类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#例举3种强制类型转换和2种隐式类型转换？"><span class="nav-number">2.</span> <span class="nav-text">例举3种强制类型转换和2种隐式类型转换？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#split-join-的区别"><span class="nav-number">3.</span> <span class="nav-text">split() join() 的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组方法pop-push-unshift-shift"><span class="nav-number">4.</span> <span class="nav-text">数组方法pop() push() unshift() shift()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IE和DOM事件流的区别"><span class="nav-number">5.</span> <span class="nav-text">IE和DOM事件流的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IE和标准下有哪些兼容性的写法"><span class="nav-number">6.</span> <span class="nav-text">IE和标准下有哪些兼容性的写法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ajax请求的时候get-和post方式的区别"><span class="nav-number">7.</span> <span class="nav-text">ajax请求的时候get 和post方式的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#call和apply的区别"><span class="nav-number">8.</span> <span class="nav-text">call和apply的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ajax请求时，如何解析json数据"><span class="nav-number">9.</span> <span class="nav-text">ajax请求时，如何解析json数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#写一个获取非行间样式的函数"><span class="nav-number">10.</span> <span class="nav-text">写一个获取非行间样式的函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#事件委托-代理-是什么"><span class="nav-number">11.</span> <span class="nav-text">事件委托(代理)是什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#闭包是什么，有什么特性，对页面有什么影响"><span class="nav-number">12.</span> <span class="nav-text">闭包是什么，有什么特性，对页面有什么影响</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何阻止事件冒泡和默认事件"><span class="nav-number">13.</span> <span class="nav-text">如何阻止事件冒泡和默认事件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解释jsonp的原理，以及为什么不是真正的ajax"><span class="nav-number">14.</span> <span class="nav-text">解释jsonp的原理，以及为什么不是真正的ajax</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#javascript的本地对象，内置对象和宿主对象"><span class="nav-number">15.</span> <span class="nav-text">javascript的本地对象，内置对象和宿主对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#document-load-和document-ready的区别"><span class="nav-number">16.</span> <span class="nav-text">document load 和document ready的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#”-”和“-”的不同"><span class="nav-number">17.</span> <span class="nav-text">”==”和“===”的不同</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#javascript的同源策略"><span class="nav-number">18.</span> <span class="nav-text">javascript的同源策略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#最快捷的数组求最大值"><span class="nav-number">19.</span> <span class="nav-text">最快捷的数组求最大值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#排序算法"><span class="nav-number">20.</span> <span class="nav-text">排序算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#冒泡排序"><span class="nav-number">21.</span> <span class="nav-text">冒泡排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#null和undefined的区别："><span class="nav-number">22.</span> <span class="nav-text">null和undefined的区别：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用闭包的注意点："><span class="nav-number">23.</span> <span class="nav-text">使用闭包的注意点：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#请解释变量声明提升"><span class="nav-number">24.</span> <span class="nav-text">请解释变量声明提升</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何从浏览器的URL中获取查询字符串参数"><span class="nav-number">25.</span> <span class="nav-text">如何从浏览器的URL中获取查询字符串参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#arguments是什么？"><span class="nav-number">26.</span> <span class="nav-text">arguments是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是”use-strict”-使用它的好处和坏处分别是什么"><span class="nav-number">27.</span> <span class="nav-text">什么是”use strict”;?使用它的好处和坏处分别是什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是回调函数"><span class="nav-number">28.</span> <span class="nav-text">什么是回调函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用-typeof-bar-“object”-判断-bar-是不是一个对象有神马潜在的弊端？如何避免这种弊端？"><span class="nav-number">29.</span> <span class="nav-text">使用 typeof bar === “object” 判断 bar 是不是一个对象有神马潜在的弊端？如何避免这种弊端？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#下面的代码会输出什么？为什么？"><span class="nav-number">30.</span> <span class="nav-text">下面的代码会输出什么？为什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#逻辑运算"><span class="nav-number">31.</span> <span class="nav-text">逻辑运算</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#在-JavaScript，常见的-false-值"><span class="nav-number">32.</span> <span class="nav-text">在 JavaScript，常见的 false 值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解释下面代码的输出"><span class="nav-number">33.</span> <span class="nav-text">解释下面代码的输出</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解释下面代码的输出-1"><span class="nav-number">34.</span> <span class="nav-text">解释下面代码的输出</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#请写出以下输出结果"><span class="nav-number">35.</span> <span class="nav-text">请写出以下输出结果</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#谈谈你对Ajax的理解？-概念、特点、作用"><span class="nav-number">36.</span> <span class="nav-text">谈谈你对Ajax的理解？(概念、特点、作用)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#说说你对延迟对象deferred的理解"><span class="nav-number">37.</span> <span class="nav-text">说说你对延迟对象deferred的理解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是跨域，如何实现跨域访问"><span class="nav-number">38.</span> <span class="nav-text">什么是跨域，如何实现跨域访问?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么要使用模板引擎"><span class="nav-number">39.</span> <span class="nav-text">为什么要使用模板引擎</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#根据你的理解-请简述JavaScript脚本的执行原理"><span class="nav-number">40.</span> <span class="nav-text">根据你的理解,请简述JavaScript脚本的执行原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JavaScript的数据类型有哪些"><span class="nav-number">41.</span> <span class="nav-text">JavaScript的数据类型有哪些</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#谈谈你This对象的理解"><span class="nav-number">42.</span> <span class="nav-text">谈谈你This对象的理解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JavaScript对象的几种创建方式"><span class="nav-number">43.</span> <span class="nav-text">JavaScript对象的几种创建方式?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#请写出js内存泄漏的问题"><span class="nav-number">44.</span> <span class="nav-text">请写出js内存泄漏的问题?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JS应该放在什么位置？"><span class="nav-number">45.</span> <span class="nav-text">JS应该放在什么位置？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#说说你对Promise的理解"><span class="nav-number">46.</span> <span class="nav-text">说说你对Promise的理解?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#说说你对原型（prototype）理解"><span class="nav-number">47.</span> <span class="nav-text">说说你对原型（prototype）理解?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#纯数组排序"><span class="nav-number">48.</span> <span class="nav-text">纯数组排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组对象排序"><span class="nav-number">49.</span> <span class="nav-text">数组对象排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#promise"><span class="nav-number">50.</span> <span class="nav-text">promise</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何禁用网页菜单右键？"><span class="nav-number">51.</span> <span class="nav-text">如何禁用网页菜单右键？</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">_doucc</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.1.1</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.1"></script>

  <script src="/js/motion.js?v=7.1.1"></script>



  
  


  <script src="/js/schemes/muse.js?v=7.1.1"></script>



  
  <script src="/js/scrollspy.js?v=7.1.1"></script>
<script src="/js/post-details.js?v=7.1.1"></script>



  


  <script src="/js/next-boot.js?v=7.1.1"></script>


  

  

  

  


  


  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
